# -*- coding: utf-8 -*-
"""
/***************************************************************************
 pol_toolkitDockWidget
                                 A QGIS plugin
 City planning Database administration toolkit
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-12-22
        git sha              : $Format:%H$
        copyright            : (C) 2021 by Geomeletitiki SA/ Municipality of Acharnes
        email                : efstathios.lyberis@geomeletitiki.gr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import pyodbc, json


from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt import QtCore
from qgis.PyQt.QtCore import pyqtSignal, Qt
from qgis.core import QgsProject
from qgis.PyQt.QtWidgets import QTableWidgetItem, QLabel, QPushButton
from qgis.PyQt.QtGui import QPixmap, QIcon


FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'pol_toolkit_dockwidget_base.ui'))


class pol_toolkitDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()
    openingDocument = pyqtSignal(bytes)
    layer = None
    selectedFeatures = []

    pr_anal_binaries = {"sxedia":[], "txtprx": [], "txtkyr": []}  # a store for binary data contianing images


    def __init__(self, parent=None):
        """Constructor."""
        super(pol_toolkitDockWidget, self).__init__(parent)
        self.setupUi(self) #access UI objects via self.<object>


        # GUI
        self.no_anal.setVisible(False)
        self.selected_label.setVisible(False)
        self.search_ot__selected.setEnabled(False)
        

        self.layer = QgsProject.instance().mapLayersByName('Οικοδομικά Τετράγωνα')[0]
        self.layer.selectionChanged.connect(self.ot_selection_changed)



        self.search_ot_button.clicked.connect(self.searchFromText)
        self.search_ot__selected.clicked.connect(self.searchFromSelection)       

        # Open documents from clicks in the table
        self.search_ot_anal.cellClicked.connect(self.showDocument)



    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()






    def searchFromText(self):
        #Get the layer Oikodomika Tetragona
        self.layer = QgsProject.instance().mapLayersByName('Οικοδομικά Τετράγωνα')[0]

        ot_num = self.search_ot_number.text()
        pe_num = self.search_ot_pe.text()

        # read db connection properties
        settings_path = os.path.join(os.path.dirname(__file__), 'settings', 'settings.json')
        with open(settings_path, 'r') as settings_file:
            settings = json.load(settings_file)
            host = settings['DB']['Attributes']['host']
            db= settings['DB']['Attributes']['db']
            user = settings['DB']['Attributes']['user']
            passw = settings['DB']['Attributes']['passw']
        settings_file.close()

        conn = pyodbc.connect("DRIVER={};SERVER={};DATABASE={};UID={};PWD={}".format('ODBC Driver 17 for SQL Server', host.replace('/', "\\"), db, user, passw))
        #conn.setdecoding(pyodbc.SQL_WCHAR, encoding='utf-8')       #may need to specify encoding
        cursor = conn.cursor()
        

        #Find all Praxeis Analogismou which match the specific OT and PE
        query = "SELECT * FROM [polgeodb].[dbo].[anal] WHERE [analid] IN (SELECT [analid] FROM [polgeodb].[dbo].[analot] WHERE PARSENAME( [otid],3) = '{}' AND PARSENAME([otid],1) = '{}')".format(ot_num, pe_num)
    
        cursor.execute(query)
        row = cursor.fetchall()

        if row:
            self.fillTable(self.search_ot_anal, row)
        else:
            #GUI
            self.no_anal.setVisible(True)
            self.search_ot_anal.setEnabled(False)
            self.search_ot_anal.clear()
    


    def searchFromSelection(self):
        
        # read db connection properties
        settings_path = os.path.join(os.path.dirname(__file__), 'settings', 'settings.json')
        with open(settings_path, 'r') as settings_file:
            settings = json.load(settings_file)
            host = settings['DB']['Attributes']['host']
            db= settings['DB']['Attributes']['db']
            user = settings['DB']['Attributes']['user']
            passw = settings['DB']['Attributes']['passw']
        settings_file.close()

        conn = pyodbc.connect("DRIVER={};SERVER={};DATABASE={};UID={};PWD={}".format('ODBC Driver 17 for SQL Server', host.replace('/', "\\"), db, user, passw))
        #conn.setdecoding(pyodbc.SQL_WCHAR, encoding='utf-8')       #may need to specify encoding
        cursor = conn.cursor()
        

        successes = 0
        for i in range(0,len(self.selectedFeatures)):
            feature = self.selectedFeatures[i]
            ot_num = feature['ot']
            pe_num = feature['pe']


            #Find all Praxeis Analogismou which match the specific OT and PE
            query = "SELECT * FROM [polgeodb].[dbo].[anal] WHERE [analid] IN (SELECT [analid] FROM [polgeodb].[dbo].[analot] WHERE PARSENAME( [otid],3) = '{}' AND PARSENAME([otid],1) = '{}')".format(ot_num, pe_num)

            cursor.execute(query)
            row = cursor.fetchall()

            if row:
                successes+=1
                if successes == 1:
                    self.fillTable(self.search_ot_anal, row)
                else:
                    self.fillTable(self.search_ot_anal, row, False)
            elif i ==len(self.selectedFeatures) and successes == 0: #No matching entries found in the db, after searching for all the features
                #GUI
                self.no_anal.setVisible(True)
                self.search_ot_anal.setEnabled(False)
                self.search_ot_anal.clear()

         






    def fillTable(self,table, items, firstResult=True):
        if firstResult == True:
            #GUI
            self.no_anal.setVisible(False)
            self.search_ot_anal.setEnabled(True)
    
    
            table.clear()
            table.setRowCount(0)
            table.setColumnCount(11)
    
    
            table.setHorizontalHeaderLabels(['ID','Αρ. Πράξης', 'Ημ/νια', 'Φάκελος', 'Διεύθυνση', 'Αρ. Πρωτοκ. Κύρωσης', 'Ημ/νια Κύρωσης', 'ΟΤΑ', 'Σχέδιο', 'Λεκτ. Πράξης', 'Λεκτ. Κύρηξης'])
            table.horizontalHeader().setVisible(True)
        else:
            None
        
        for result in items:
            #try:
            #Add a new row to the table
            table.insertRow(table.rowCount()) 

            #For every item in the database response, put the item in the respective column
            item = QTableWidgetItem(result.analid)
            table.setItem(table.rowCount()-1, 0, item)
            item = QTableWidgetItem(result.arpraxis)
            table.setItem(table.rowCount()-1, 1, item)
            item = QTableWidgetItem(str(result.dateprax))
            table.setItem(table.rowCount()-1, 2, item)
            item = QTableWidgetItem(result.fakel)
            table.setItem(table.rowCount()-1, 3, item)
            item = QTableWidgetItem(result.address)
            table.setItem(table.rowCount()-1, 4, item)
            item = QTableWidgetItem(result.arprotkyr)
            table.setItem(table.rowCount()-1, 5, item)
            item = QTableWidgetItem(str(result.datekyr))
            table.setItem(table.rowCount()-1, 6, item)
            item = QTableWidgetItem(result.ota)
            table.setItem(table.rowCount()-1, 7, item)


            #Fields containing binary data

            # 1. imagesxed
            pixmap = QPixmap(os.path.dirname(__file__) + "/icons/blueprint_small.png")
            pixmap.scaled(10,10)
            label = QLabel(table)
            label.setAlignment(Qt.AlignCenter)
            label.setPixmap(pixmap)
            label.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
            table.setCellWidget(table.rowCount()-1, 8, label)

            self.pr_anal_binaries['sxedia'].append(result.imagesxed)

            # 2. imagetxtprx
            pixmap = QPixmap(os.path.dirname(__file__) + "/icons/doc_small.png")
            pixmap.scaled(10,10)
            label = QLabel(table)
            label.setPixmap(pixmap)
            label.setAlignment(Qt.AlignCenter)
            label.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
            table.setCellWidget(table.rowCount()-1, 9, label)

            self.pr_anal_binaries['txtprx'].append(result.imagetxtprx)


            # 3. imagetxtkyr
            pixmap = QPixmap(os.path.dirname(__file__) + "/icons/doc_small.png")
            pixmap.scaled(10,10)
            label = QLabel(table)
            label.setPixmap(pixmap)
            label.setAlignment(Qt.AlignCenter)
            label.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
            table.setCellWidget(table.rowCount()-1, 10, label)

            self.pr_anal_binaries['txtkyr'].append(result.imagetxtkyr)
            #except:
            #    continue


    def showDocument(self, row, column):
        if column == 8:
            self.openingDocument.emit(self.pr_anal_binaries["sxedia"][row])
        elif column == 9:
            self.openingDocument.emit(self.pr_anal_binaries["txtprx"][row])
        elif column == 10:
            self.openingDocument.emit(self.pr_anal_binaries["txtkyr"][row])


    def ot_selection_changed(self, selection):
        if len(selection) == 0:
            self.selected_label.setVisible(False)
            self.search_ot__selected.setEnabled(False)
        else:
            for feature in self.layer.selectedFeatures():
                ot = feature['ot_pl_id'].split('.')[0]
                pe = feature['ot_pl_id'].split('.')[1]

                self.selectedFeatures.append({'ot': ot,'pe':pe})


            if len(selection) > 1:
                self.selected_label.setVisible(True)
                self.selected_label.setText("<font color='Green'>{} επιλεγμένα στοιχεία</font>".format(len(selection)))

                self.search_ot__selected.setEnabled(True)
            elif len(selection) == 1:
                self.selected_label.setVisible(True)
                self.selected_label.setText("<font color='Green'>1 επιλεγμένο στοιχείο</font>")
                self.search_ot__selected.setEnabled(True)